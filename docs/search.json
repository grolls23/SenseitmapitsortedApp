[
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "",
    "section": "",
    "text": "Use this repository to host a website for your CASA0025 final project by following these stpes:\n\nclone this repository\ninstall quarto\nedit the ‘index.qmd’ file with the contents of your project\nusing terminal, navigate to the project directory and run “quarto render”\npush the changes to your github repository\non github, navigate to Settings&gt;Pages&gt;Build and Deployment. Make sure that under “Source” it says “deploy from branch”. Under “Branch”, select “Main” in the first dropdown and “Docs” under the second drop down. Then press “Save”\n\nYour website should now be available under https://{your_username}.github.io/{your_repo_name}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sense It, Map It, Sorted - Flooding the Sindh region of Pakistan",
    "section": "",
    "text": "Fill in the sections below to provide a brief summary of your project. Each section should have no more than 100 words. Do not edit any of the headings.\n\n\nWhat is the problem you’re trying to address using this application?\nPakistan has one of the highest disaster risk levels globally. Flooding is the main hazard contributing to disaster risk in Pakistan. The country has has high exposure to riverine, flash and coastal flooding as well as tropical cyclones and high social vulnerability driven by multi-dimensional poverty. Flood risk and damage assessments exist at the national level, however, local level data on flood risk is missing. Local governments need such data for their jurisdictions in order to access adaptation funding and direct investment to the areas with highest risk.\n\n\n\nWho are you building this application for? How does it address a need this community has?\nThis application is built for local governments in Pakistan. Flood risk adaptation is at the top of the political agenda for divisional (second tier) and district (third tier) governments. In the devastating floods of 2022, one-third of the country was under water, 33 million people affected, and around 8 million people displaced. This application helps second and third tier governments in Pakistan to understand flood risk locally and support adaptation investment decisions in multi-level governance systems. The end user wants to know: Which areas are prone to flooding and what is the impact on people and the economy?\n\n\n\nFlooding in Sindh, 2022 (Source: https://news.un.org/en/story/2022/09/1126001)\n\n\nSource for numbers make reference file: https://www.worldbank.org/en/news/feature/2023/06/28/rising-from-the-waters-sindh-navigates-recovery-after-the-2022-floods\n\n\n\nWhat data are you using?\nThe application uses the following data sources:\n\nFlood events: The Global Flood Database contains 913 flood events between 2000-2018 globally and is based on MODIS imagery. Each pixel is classified as water or non-water at 250m resolution where permanent water is masked out using the Global Surface Water dataset.\nPopulation: High Resolution Population Density Maps from Data for Good. (HRSL)\nLand use: The Dynamic World Dataset contains near real time Land Use Land Cover classification based on Sentinel 2 imagery from 2015 to present. Only the classes “bulit up” and “crops” are used for the application.\n\n\n\n\n\n\n\nMethods flowchart\n\n\nHow are you using this data to address the problem?\nThe data is used to develop an indicative flood risk map at division and district level in Pakistan. Risk is commonly defined as function of hazard, exposure and vulnerability. The baseline assumption of this analysis is that areas that have been flooded in the past are expected to flood in the future. Hence, using a cumulative analysis of flood events between 2000 and 2018, the occurrence of floods is used as a proxy for exposure. A vulnerability index is calculated as a product of the raw population count and the number of flood occurrences. The results are combined into an integrated user interface.\n\n\n\nHow does your application’s interface work to address the needs of your end user?\nLocal governments in Pakistan need a simple to use application that allows for rapid identification of flood risk locally with a simple presentation of data without technical jargon. The interface has two layers. On the first (left-hand side), the user can retrieve comparative information about affected divisons and select the district they want to explore. Once selected, vulnerarbility, land use and population The user can select a district and retrieve more detailed information about the number of flood events, population affected over time and land use types affected on the right-hand side.\n\n\n\n\n\n\n\n\n\n\n\nUse this section to explain how your application works using code blocks and text explanations (no more than 500 words excluding code):\n\n\nOur project is split into 3 main parts that use different data sources: population, land-use, and vulnerability. The app.js file collects the different data layers and parts of analysis into one integrated app, deployed as a live Google Earth Engine Application. Each element is described in detail below:\n\n\nWhen the user selects a district (regional subdivision) and requests analysis of population breakdown or land use, data is aggregated from the appropriate data (population data from Data for Good and land use data from Dynamic World) using an asynchronous function. The case for land use is seen below, where an area and percentage of each landcover class is calculated using a reducer applied to pixels of a certain land class type, before being added to arrays which store the full set of areas and percentages for each type.\n  totalArea.evaluate(function(result){\n    var pixelArea = result.label_mode;\n    totalAreasqkm = pixelArea * (300 * 300 / 1000000);\n      \n    var areaPerClass = {};\n    var pctPerClass = {};\n    \n    var completedCount = 0;\n    \n    for (var i = 0; i &lt; CLASS_NAMES.length; i++) {\n      (function(index) {\n        var filteredLandUseData = landuseData.updateMask(landuseData.eq(index));\n  \n        var classCount = filteredLandUseData.reduceRegion({\n          reducer: ee.Reducer.count(),\n          geometry: region,\n          scale: 300,\n          maxPixels: 1e9\n        });\n  \n        classCount.evaluate(function(result) {\n          var pixelCount = result.label_mode;\n  \n          var pixelArea = pixelCount * (300 * 300 / 1000000);\n          areaPerClass[CLASS_NAMES[index]] = pixelArea;\n          pctPerClass[CLASS_NAMES[index]] = 100 * pixelArea / totalAreasqkm;\nThe multiplier (300 * 300 / 1000000) is a conversion from pixels to square kilometres (specific to the scale of this reducer). Population calculations applied a sum reducer instead of a count reducer, separated by age band.\n  var populationByAgeBand_aoi = HRSL_collection.reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: aoi.geometry(),\n    scale: 30,\n    maxPixels: 1e13\n  });\nThese calculations were carried out twice for both population and landcover to give a breakdown across the entire district as well as across all parts of the district ‘affected by flooding’, meaning these areas have had floods recorded in the Global Flood Database. This information is stored in a raster and accessed through the following code:\nvar region_flooded = UI_functions.getFloodedInAoi(region, globals.cumulativeFlooded);\n\n\n\nUsing the HRSL data and the GFD, The vulnerability index is a product of the raw population count and the number of flood occurrences, calculated as below:\nvar vulnerabilityIndex = clippedHRSL.multiply(clippedCumulativeFlooded);\nGiven, that population data is at a high resolution (30m), when mapping this layer, we use a smoothing kernel of size 500m kernel, in order to make its visualisation prettier. This is done using the function below:\nvar kernel = ee.Kernel.square({\n  radius: 500,\n  units: 'meters'\n});\n\nvar interpolate = function(image) {\n  var smoothed = image.focal_mean({kernel: kernel, iterations: 1});\n  var filled = image.unmask(smoothed);\n  return filled;\n};\n\nvar smoothedVulnerabilityIndex = interpolate(vulnerabilityIndex).updateMask(interpolate(vulnerabilityIndex).gt(0));"
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "Sense It, Map It, Sorted - Flooding the Sindh region of Pakistan",
    "section": "",
    "text": "Fill in the sections below to provide a brief summary of your project. Each section should have no more than 100 words. Do not edit any of the headings.\n\n\nWhat is the problem you’re trying to address using this application?\nPakistan has one of the highest disaster risk levels globally. Flooding is the main hazard contributing to disaster risk in Pakistan. The country has has high exposure to riverine, flash and coastal flooding as well as tropical cyclones and high social vulnerability driven by multi-dimensional poverty. Flood risk and damage assessments exist at the national level, however, local level data on flood risk is missing. Local governments need such data for their jurisdictions in order to access adaptation funding and direct investment to the areas with highest risk.\n\n\n\nWho are you building this application for? How does it address a need this community has?\nThis application is built for local governments in Pakistan. Flood risk adaptation is at the top of the political agenda for divisional (second tier) and district (third tier) governments. In the devastating floods of 2022, one-third of the country was under water, 33 million people affected, and around 8 million people displaced. This application helps second and third tier governments in Pakistan to understand flood risk locally and support adaptation investment decisions in multi-level governance systems. The end user wants to know: Which areas are prone to flooding and what is the impact on people and the economy?\n\n\n\nFlooding in Sindh, 2022 (Source: https://news.un.org/en/story/2022/09/1126001)\n\n\nSource for numbers make reference file: https://www.worldbank.org/en/news/feature/2023/06/28/rising-from-the-waters-sindh-navigates-recovery-after-the-2022-floods\n\n\n\nWhat data are you using?\nThe application uses the following data sources:\n\nFlood events: The Global Flood Database contains 913 flood events between 2000-2018 globally and is based on MODIS imagery. Each pixel is classified as water or non-water at 250m resolution where permanent water is masked out using the Global Surface Water dataset.\nPopulation: High Resolution Population Density Maps from Data for Good. (HRSL)\nLand use: The Dynamic World Dataset contains near real time Land Use Land Cover classification based on Sentinel 2 imagery from 2015 to present. Only the classes “bulit up” and “crops” are used for the application.\n\n\n\n\n\n\n\nMethods flowchart\n\n\nHow are you using this data to address the problem?\nThe data is used to develop an indicative flood risk map at division and district level in Pakistan. Risk is commonly defined as function of hazard, exposure and vulnerability. The baseline assumption of this analysis is that areas that have been flooded in the past are expected to flood in the future. Hence, using a cumulative analysis of flood events between 2000 and 2018, the occurrence of floods is used as a proxy for exposure. A vulnerability index is calculated as a product of the raw population count and the number of flood occurrences. The results are combined into an integrated user interface.\n\n\n\nHow does your application’s interface work to address the needs of your end user?\nLocal governments in Pakistan need a simple to use application that allows for rapid identification of flood risk locally with a simple presentation of data without technical jargon. The interface has two layers. On the first (left-hand side), the user can retrieve comparative information about affected divisons and select the district they want to explore. Once selected, vulnerarbility, land use and population The user can select a district and retrieve more detailed information about the number of flood events, population affected over time and land use types affected on the right-hand side."
  },
  {
    "objectID": "index.html#the-application",
    "href": "index.html#the-application",
    "title": "Sense It, Map It, Sorted - Flooding the Sindh region of Pakistan",
    "section": "",
    "text": "&lt;iframe src=\"https://ee-yankomagn.projects.earthengine.app/view/floods-pakistan\" width=\"100%\" height=\"700px\"&gt;&lt;/iframe&gt;"
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Sense It, Map It, Sorted - Flooding the Sindh region of Pakistan",
    "section": "",
    "text": "Use this section to explain how your application works using code blocks and text explanations (no more than 500 words excluding code):\n\n\nOur project is split into 3 main parts that use different data sources: population, land-use, and vulnerability. The app.js file collects the different data layers and parts of analysis into one integrated app, deployed as a live Google Earth Engine Application. Each element is described in detail below:\n\n\nWhen the user selects a district (regional subdivision) and requests analysis of population breakdown or land use, data is aggregated from the appropriate data (population data from Data for Good and land use data from Dynamic World) using an asynchronous function. The case for land use is seen below, where an area and percentage of each landcover class is calculated using a reducer applied to pixels of a certain land class type, before being added to arrays which store the full set of areas and percentages for each type.\n  totalArea.evaluate(function(result){\n    var pixelArea = result.label_mode;\n    totalAreasqkm = pixelArea * (300 * 300 / 1000000);\n      \n    var areaPerClass = {};\n    var pctPerClass = {};\n    \n    var completedCount = 0;\n    \n    for (var i = 0; i &lt; CLASS_NAMES.length; i++) {\n      (function(index) {\n        var filteredLandUseData = landuseData.updateMask(landuseData.eq(index));\n  \n        var classCount = filteredLandUseData.reduceRegion({\n          reducer: ee.Reducer.count(),\n          geometry: region,\n          scale: 300,\n          maxPixels: 1e9\n        });\n  \n        classCount.evaluate(function(result) {\n          var pixelCount = result.label_mode;\n  \n          var pixelArea = pixelCount * (300 * 300 / 1000000);\n          areaPerClass[CLASS_NAMES[index]] = pixelArea;\n          pctPerClass[CLASS_NAMES[index]] = 100 * pixelArea / totalAreasqkm;\nThe multiplier (300 * 300 / 1000000) is a conversion from pixels to square kilometres (specific to the scale of this reducer). Population calculations applied a sum reducer instead of a count reducer, separated by age band.\n  var populationByAgeBand_aoi = HRSL_collection.reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: aoi.geometry(),\n    scale: 30,\n    maxPixels: 1e13\n  });\nThese calculations were carried out twice for both population and landcover to give a breakdown across the entire district as well as across all parts of the district ‘affected by flooding’, meaning these areas have had floods recorded in the Global Flood Database. This information is stored in a raster and accessed through the following code:\nvar region_flooded = UI_functions.getFloodedInAoi(region, globals.cumulativeFlooded);\n\n\n\nUsing the HRSL data and the GFD, The vulnerability index is a product of the raw population count and the number of flood occurrences, calculated as below:\nvar vulnerabilityIndex = clippedHRSL.multiply(clippedCumulativeFlooded);\nGiven, that population data is at a high resolution (30m), when mapping this layer, we use a smoothing kernel of size 500m kernel, in order to make its visualisation prettier. This is done using the function below:\nvar kernel = ee.Kernel.square({\n  radius: 500,\n  units: 'meters'\n});\n\nvar interpolate = function(image) {\n  var smoothed = image.focal_mean({kernel: kernel, iterations: 1});\n  var filled = image.unmask(smoothed);\n  return filled;\n};\n\nvar smoothedVulnerabilityIndex = interpolate(vulnerabilityIndex).updateMask(interpolate(vulnerabilityIndex).gt(0));"
  }
]